<script>
import {cloneDeepWith, isEmpty, isPlainObject} from 'lodash-es';
import {createClient as Supabase} from '@supabase/supabase-js'
import SupabaseReactive from '@momsfriendlydevco/supabase-reactive';
import {BlobWriter as ZipBlobWriter, BlobReader as ZipBlobReader, ZipWriter} from '@zip.js/zip.js';

/**
* $state service
* Available on all Vue models as `vm.$state`
*
* This module uses a Unix style addressing style for data entities:
*
* /:entity/:id/:operand...
*
* e.g. /projects/12345/My Directory/My File.png
*
* So fetching a data record would be `vm.this.get('/projects/1234')` or `vm.this.subscribe('/projects/1234')`
*
*/
export default {
	name: '$state',
	data() { return {
		/**
		* Supabase client used to pull / push / subscribe to state
		*
		* @type {SupabaseClient}
		*/
		supabase: null,


		/**
		* Steps used to resolve file-type information
		* This is an array of different sync funciton operations to try, the first function to provide an object is used as the response
		* Each function is called as `(file:SupabaseFile)`
		*
		* @type {Array<Function>}
		*/
		fileTypes: [
			// Step - Simple `ext` matching
			function(file) {
				return this.fileTypesLookup[file.parsedName.ext];
			},

			// Step - return one-size-fits-all information (always succeeds)
			function() {
				return {type: 'Unknown file type', icon: 'fas fa-file-lines'};
			},
		],


		/**
		* Basic file-type icon map
		* Used by the intermediate step of `this.fileTypesMatch`
		* This is the ext -> FontAwesome mapping for anything that isn't matched via `this.fileIcon(fie)`
		* If the key is a function it is called as the sync function `(rawFile)` and expected to return an object or nullish - in which case its rejected
		*
		* @type {Object} lower case extension -> FA icon mapping
		*/
		fileTypesLookup: {
			'7z': {type: '7zip compressed archive', icon: 'far fa-file-archive'},
			'avi': {type: 'Movie file', icon: 'far fa-file-video'},
			'doc': {type: 'Microsoft Word Document', icon: 'far fa-file-word'},
			'docx': {type: 'Microsoft Word Document', icon: 'far fa-file-word'},
			'gif': {type: 'GIF image file', icon: 'far fa-file-image'},
			'html': {type: 'Web-page', icon: 'far fa-file-code'},
			'jpeg': {type: 'JPEG image file', icon: 'far fa-file-image'},
			'jpg': {type: 'JPEG image file', icon: 'far fa-file-image'},
			'json': {type: 'JSON data', icon: 'far fa-file-code'},
			'odg': {type: 'LibreOffice drawing', icon: 'far fa-file-image'},
			'odp': {type: 'LibreOffice presentation', icon: 'far fa-file-powerpoint'},
			'ods': {type: 'LibreOffice spreadsheet', icon: 'far fa-file-excel'},
			'odt': {type: 'LibreOffice document', icon: 'far fa-file-word'},
			'pdf': {type: 'PDF file', icon: 'far fa-file-pdf'},
			'png': {type: 'PNG image file', icon: 'far fa-file-image'},
			'ppt': {type: 'Microsoft PowerPoint file', icon: 'far fa-file-powerpoint'},
			'pptx': {type: 'Microsoft PowerPoint file', icon: 'far fa-file-powerpoint'},
			'rar': {type: 'RAR compressed archive', icon: 'far fa-file-archive'},
			'svg': {type: 'Scalable Vector Graphics image file', icon: 'far fa-file-image'},
			'txt': {type: 'Plain text file', icon: 'far fa-file-alt'},
			'xls': {type: 'Microsoft Excel file', icon: 'far fa-file-excel'},
			'xlsx': {type: 'Microsoft Excel file', icon: 'far fa-file-excel'},
			'zip': {type: 'Zip compressed archive', icon: 'far fa-file-archive'},
		},


		/**
		* File transcode handlers, called in sequence whenever a file upload occurs
		* These are funtions, executed in series with the first non-undefined response expected to mutate the file upload
		* @type {Array<Function>} Function called as `(File)`
		*/
		fileTranscoders: [],
	}},
	props: {
		/**
		* Options for throttling writes to the server
		* The options here match the Lodash `debounce` function along with a `wait` time in milliseconds
		*
		* @type {Object}
		* @property {Number} throttle Throttle all writes by this time in milliseconds, set to falsy to disable
		*/
		throttle: {type: Object, default: ()=> { return {
			wait: 200,
			maxWait: 2000,
			leading: false,
			trailing: true,
		}}},


		/**
		* Supabase URL used for connections
		* @type {String}
		*/
		supabaseUrl: {type: String, required: true},


		/**
		* Supabase API key used for connections
		* @type {String}
		*/
		supabaseKey: {type: String, required: true},
	},
	methods: {

		// Pathing utilities - splitPath() {{{
		/**
		* Split a simple path into Supabase compatible entity + filters
		*
		* @param {String|Array<String>|Object} path Path to seperate in slash notation or array form
		* @param {Object} [options] Additional options to mutate behaviour
		* @param {Boolean} [options.requireEntity=true] Throw if a entity is not deteceted in the decoded output
		* @param {Boolean} [options.requireId=false] Throw if an ID is not detected in the decoded output
		* @param {Boolean} [options.requireOperand=false] Throw if an operand is not detected in the decoded output
		*
		* @returns {Object} An object composed of `{entity: String, id: String, filter: Object}`
		* @property {String} [entity] The entity the path is referring to
		* @property {String} [id] The Unique ID the path is referring to
		* @property {String} [operand] Any remaining pathing
		*
		* @example Split a given path into parts
		* this.splitPath('/projects/1234/My dir/My file.png') -> // {entity: 'projects', id: '1234', operand: 'My dir/My file.png'}
		*/
		splitPath(path, options) {
			let settings = {
				requireEntity: true,
				requireId: false,
				requireOperand: false,
				...options,
			};

			let entity, id, operand;

			if (Array.isArray(path)) { // Split array from form: `[$entity, $ID, $operand]`
				[entity, id, operand] = path;
			} else if (typeof path == 'object' && path !== null) { // path could be an object literal, also check for null
				entity = path.entity;
				id = path.id;
				operand = path.operand;
			} else if (typeof path == 'string') { // Split string
				const parts = path
					.replace(/^\//, '') // Remove root slash
					.split('/');

				entity = parts[0];
				id = parts[1]; // Will be undefined if parts.length < 2

				if (parts.length > 2) {
					operand = parts.slice(2).join('/'); // Join all remaining parts for the operand
				} else {
					operand = undefined;
				}
			} else {
				throw new Error('Unknown input type to splitPath');
			}

			if (settings.requireEntity && !entity) throw new Error(`Could not extract entity from path "${path}"`);
			if (settings.requireId && (!id || id == 'undefined')) throw new Error(`Could not extract ID from path "${path}"`);
			if (settings.requireOperand && (!operand || operand == 'undefined')) throw new Error(`Could not extract operand from path "${path}"`);

			return {entity, id, operand};
	},
		// }}}

		// Record / Row handling - get(), set(), create() {{{
		/**
		* Fetch a current snapshot of a Supabase path
		* This fetches a record state *as it is now*, use `this.subscribe()` to also update local state on changes
		*
		* @param {String|Array<String>} path The path to retrieve
		* @param {*} [fallback] Optional fallback if the path does not exist
		* @param {Object} [options] Additional options to mutate behaviour
		* @param {Boolean} [options.id=true] Include ID of the entity in the output
		* @returns {Promise<Object>} A promise which will resolve with the current snapshot value
		*/
		get(path, fallback, options) {
			let settings = {
				id: true,
				...options,
			};

			let {entity, id} = this.splitPath(path, {requireEntity: true, requireId: true});

			return this.supabase
				.from(entity)
				.select('id, data')
				.limit(1)
				.eq('id', id)
				.maybeSingle() // Note we use maybeSingle() instead of single() as Supabase throws a 406 unless we're specific we could have no value
				.then(payload => {
					if (payload.error) {
						return Promise.reject(payload.error.message);
					} else if (payload.data) {
						return {
							...(settings.id && {
								id: payload.data.id,
							}),
							...payload.data.data,
						};
					} else {
						return fallback;
					}
				});
		},

		/**
		* Set a snapshot of a Supabase path
		* NOTE: This is actually a merge operation not a pure 'overwrite everything' step, use `replace()` if optimizing
		*
		* @param {String|Array<String>} path The path to set
		* @param {Object} data Data to merge in with the current value
		* @returns {Promise} A promise which resolves when the operation has completed
		*/
		set(path, data) {
			let {entity, id} = this.splitPath(path, {requireEntity: true, requireId: true});
			this.debug('SET', path, '=', data);

			return this.get({entity, id}, {})
				.then(existingData => this.supabase
					.from(entity)
					.update({
						data: {
							...existingData,
							...tidyValue(data),
						},
					})
					.eq('id', id)
					.select('id')
				)
				.catch(error => {
						console.error("Error fetching existing data:", error);
						return Promise.reject(error);
				})
				.then(payload => payload.error?.message && Promise.reject(payload.error.message))
		},


		/**
		* Tidy JSON field data so that is safe from private methods (anything starting with '$' or '_', proxies or other non POJO slush
		* @param {Object|Array} input Input object to tidy
		* @returns {Object|Array} POJO, scalar output
		*/
		tidyValue(input) {
			return cloneDeepWith(input, (v, k) => // Clone so we break up all the proxy slush and store primatives only
				!/^[$\_]/.test(k) // Key doesn't start with '$' or '_'
				&& (
					['string', 'number', 'boolean'].includes(typeof v) // Basic scalar types
					|| Array.isArray(v)
					|| isPlainObject(v)
				)
					? undefined // Use default cloning behaviour
					: null // Strip from output
			);
		},


		/**
		* Replace a snapshot of a Supabase path
		* This is a super-optimized upsert with no fetch for original data, use `bindData()` or `create()` + `set()` for more friendly functions
		*
		* @param {String|Array<String>} path The path to set
		* @param {Object} data Data to replace current value with
		* @returns {Promise} A promise which resolves when the operation has completed
		*/
		replace(path, data) {
			let {entity, id} = this.splitPath(path, {requireEntity: true, requireId: true});
			this.debug('REPLACE', path, '=', data);

			return this.supabase
				.from(entity)
				.upsert({
					id,
					data: this.tidyValue(data),
				}, {
					onConflict: 'id',
					ignoreDuplicates: false,
				})
				.eq('id', id)
				.select('id')
				.then(payload => payload.error?.message && Promise.reject(payload.error.message))
		},


		/**
		* Create a new entity at the named path including optional data
		*
		* @param {String|Array<String>} path The path to create
		* @param {Object} [data] Initial data to populate
		* @returns {Object} Snapshot of the inserted record - use dataBind to subscribe to the changes by its ID
		*/
		create(path, data) {
			let {entity} = this.splitPath(path, {requireEntity: true, requireId: false});

			return this.supabase
				.from(entity)
				.insert({data})
				.single()
				.select()
				.then(payload => payload.data || Promise.reject(payload.error.message))
				.then(row => ({
					id: row.id,
					...row.data,
				}))
		},
		// }}}

		// Subscribe - bindData() {{{
		/**
		* Return a Vue compatible reactive object which subscribes to read/write changes
		* This is really just a wrapper for @MomsFriendlyDevCo/Supabase-Reactive
		*
		* @param {String|Array<String>} path The path to bind to
		* @param {Object} [options] Additional options to mutate behaviour, see @MomsFriendlyDevCo/Supabase-Reactive for details
		* @returns {VueObservable} The observable object
		*/
		bindData(path, options) {
			return SupabaseReactive(path, {
				supabase: this.supabase,
				debug: this.debug.bind(this, 'REACTIVE'),
				...options,
			});
		},


		/**
		* Stop watching a remote path and release all local hooks
		*
		* @param {String|Array<String>} path The path to stop watching
		* @returns {Promise<Boolean>} Boolean true if anything was actually released
		*/
		releasePath(path) {
			let {docName, docPath} = this.splitPath(path);

			if (!this.boundPaths[docName]) return false;

			return Promise.all([
				this.boundPaths[docName].record.unsubscribe(docPath, this.boundPaths[docName].callback),
				this.boundPaths[docName].record.discard(),
			])
				.then(()=> delete this.boundPaths[docName])
				.then(()=> true)
		},
		// }}}

		// Files / storage - fileList(), fileUpload(), fileTranscode(), fileGet(), fileSet(), fileDownload(), fileZip(), fileSnapshot(), fileRemove(), fileIcon() {{{
		/**
		* Storage file schema
		* Returned by `this.fileList()`
		*
		* @name SupabaseFile
		* @property {String} id A UUID string representing the unique ID of the file
		* @property {String} name Relative name path (can contain prefix directories) for the human readable file name
		* @property {String} path Internal path to the file, used to pass the file onto other functions
		* @property {Object} parsedName An object representing meta file parts of a file name
		* @property {String} parsedName.basename The filename + extention (i.e. everything without directory name)
		* @property {String} parsedName.filename The file portion of the name (basename without the extension)
		* @property {String} parsedName.ext The extension portion of the name (always lower case)
		* @property {String} parsedName.dirName The directory path portion of the name
		* @property {Date} created A date representing when the file was created
		* @property {Date} modified A date representing when the file was created
		* @property {Date} accessed A date representing when the file was last accessed
		* @property {Number} size Size, in bytes, of the file
		* @property {String} mime The associated mime type for the file
		*
		* @property {Object} [meta] Meta information pulled from the corresponding fileMeta table, if `{meta: true}` is enabled when requesting the file list
		*
		* @property {String} icon CSS icon to display for the file (extracted from the file name by `this.fileType()`)
		* @property {String} type Human readable descrition of the file name (extracted from the file name by `this.fileType()`)
		* @property {String} [href] Optional href within TERA we can direct to to manage the file (extracted from the file name by `this.fileType()`)
		*/


		/**
		* Fetch the contents of a given storage path
		*
		* @param {String|Array<String>} path The path to list
		* @param {Object} [options] Additional options to mutate behaviour
		* @param {Number} [options.limit=0] Limit file count
		* @param {Number} [options.offset=0] Offset file count
		* @param {String} [options.sort='name'] Optional sort criteria, begin field with '-' if reverse order is required
		* @param {String} [options.search] Optional search string to filter by
		* @param {Boolean} [options.meta=true] Pull meta information for each file entity
		* @param {Function} [options.metaPath] Function, called as `(rawFile)` which returns the Path to use when fetching meta data
		* @param {Number} [options.maxDepth=50] Maximum recursion depth for folders. 0 means no recursion.
		* @param {Number} [options._currentDepth=0] Internal: Tracks current recursion depth.
		*
		* @returns {Promise<Array<SupabaseFile>>} List of found files for the given path
		*/
		fileList(path, options = {}) {
			let defaultSettings = {
				limit: 0,
				offset: 0,
				sort: 'name',
				search: null,
				meta: true,
				metaPath: rawFile => `/fileMeta/${rawFile.id}`,
				maxDepth: 50,
				_currentDepth: 0,
				...options,
			};

			// Ensure options for recursive calls don't accidentally inherit _currentDepth from a manual call
			let settings = { ...defaultSettings, ...options };
			if (options._currentDepth === undefined) {
				settings._currentDepth = 0;
			}

			let {entity, id: firstPartOfPath, operand: restOfPath } = this.splitPath(path, {requireEntity: true, requireId: true});

			// Construct path from segments returned from splitPath
			let pathWithinBucket = firstPartOfPath || '';
			if (restOfPath) {
				pathWithinBucket = pathWithinBucket ? `${pathWithinBucket}/${restOfPath}` : restOfPath;
			}
			// Ensure pathWithinBucket does not have a leading slash for Supabase `list` method,
			// and is empty string for root.
			if (pathWithinBucket.startsWith('/')) pathWithinBucket = pathWithinBucket.substring(1);
			if (pathWithinBucket === '/') pathWithinBucket = '';

			this.debug('fileList(', path, options, ')');
			return this.supabase.storage
				.from(entity)
				.list(pathWithinBucket, {
					...(settings.search && {search: settings.search}),
					...(settings.limit && {limit: settings.limit}),
					...(settings.offset && {offset: settings.offset}),
					...(settings.sort && {
						sortBy: settings.sort.startsWith('-')
							? {column: settings.sort.substr(1), order: 'desc'}
							: {column: settings.sort, order: 'asc'}
					}),
				})
				.then(({data, error}) => {
					if (error) {
						console.error(`Error listing storage at path "${path}" (bucket: ${entity}, pathInBucket: ${pathWithinBucket}):`, error);
						return Promise.reject(error.message || 'Error listing files');
					}
					if (!data) return Promise.resolve([]); // No data or empty folder

					return Promise.all((data).map(rawFile => {
						const isFolder = rawFile.id === null;
						const itemName = rawFile.name;
						const currentBasePath = path.replace(/\/$/, ''); // Remove trailing slash from current path if any
						const itemFullPath = `${currentBasePath}/${itemName}`;

						// Base structure for both files and folders
						let itemStructure = {
							id: rawFile.id, // Will be null for folders
							name: itemName,
							path: itemFullPath,
							parsedName: this._parsePath('/' + itemName),
							created: rawFile.created_at ? new Date(rawFile.created_at) : null,
							modified: rawFile.updated_at ? new Date(rawFile.updated_at) : null,
							accessed: rawFile.last_accessed_at ? new Date(rawFile.last_accessed_at) : null,
							size: !isFolder ? rawFile.metadata?.size : null,
							mime: !isFolder ? rawFile.metadata?.mimetype : null,
							isFolder: isFolder,
						};

						if (isFolder) {
							// It's a folder
							itemStructure.meta = {}; // Folders don't have 'fileMeta' in the same way
							itemStructure.files = []; // Initialize files array for the folder

							// Apply fileType (might give a generic folder icon)
							Object.assign(itemStructure, this.fileType(itemStructure));


							if (settings._currentDepth < settings.maxDepth) {
								// Recursively call fileList for the subdirectory
								const subFolderOptions = {
									...settings, // Pass along original options
									_currentDepth: settings._currentDepth + 1, // Increment depth
								};
								return this.fileList(itemFullPath, subFolderOptions)
									.then(subFiles => {
										itemStructure.files = subFiles;
										return itemStructure;
									});
							} else {
								// Max depth reached, don't recurse further
								console.warn('[fileList] Max depth reached while recursively searching folders, current depth:', settings._currentDepth);
								return Promise.resolve(itemStructure);
							}

						} else {
							// It's a file, fetch metadata if enabled
							return Promise.resolve()
								.then(() => settings.meta
									? this.get(settings.metaPath(rawFile), {}, {id: false})
									: Promise.resolve({})
								)
								.then(meta => {
									itemStructure.meta = meta;
									// Merge in output of this.fileType() for the file
									return Object.assign(itemStructure, this.fileType(itemStructure));
								});
						}
					}));
				});
		},


		/**
		* Prompt for and upload a file
		*
		* @param {String|Array<String>} path The path to upload to (not the same as the file name)
		* @param {Object} [options] Additional options to mutate behaviour
		* @param {File|Blob|FormData|Object|Array} [options.file] Existing File object as a binary type (File, Blob, FormData) or a POJO (Array, Object), If omitted a file is prompted for
		* @param {Boolean} [options.overwrite=true] Allow overwriting existing files if the path matches
		* @param {String} [options.mode='auto'] Which method to use when uploading, if 'auto' this is guessed from context but some processing can be skipped if specified
		* @param {Object} [options.meta] Meta information to attach to the file, only applicable if `{multiple:false}`
		* @param {Boolean} [options.multiple=false] If prompting, allow multiple file selection (conflicts with `meta`)
		* @param {String} [options.accept] If prompting, Add additional file type restrictions
		* @param {Boolean} [options.toast=true] Use $toast.loading to show progress while uploading the file
		* @param {Function} [options.metaPath] Function, called as `(rawFile:File)` which returns the Path to use when setting meta data
		* @param {Boolean} [options.transcoders=true] Apply transcoders to uploaded files
		* @param {Number} [options.cacheControl=3600] Time the file should be cached within CDNs
		*
		* @returns {Promise<Array<Object>>} A promise which resolves to raw Supabase return data for each file uploaded
		* @property {String} id The ID of the uploaded file
		* @property {String} fullPath The fully qualified, relative path within Supabase for the uploaded file
		* @property {String} path The relative path within the Supabase bucket for the uploaded file
		*/
		fileUpload(path, options) {
			let settings = {
				file: null,
				overwrite: false,
				mode: 'auto',
				name: null,
				meta: null,
				multiple: false,
				accept: null,
				toast: true,
				metaPath: rawFile => `/fileMeta/${rawFile.id}`,
				transcoders: true,
				cacheControl: 3600,
				...options,
			};
			let toastId; // Eventual toastID used to track the loading progress
			let {entity, id, operand} = this.splitPath(path, {requireEntity: true, requireId: true});
			const pathPrefix = [id, operand].filter(Boolean).join('/');

			// Sanity checks {{{
			if (settings.multiple && settings.meta) throw new Error('Cannot specify {multiple:true} + {meta:Object} at the same time - upload one file or wrap this function in Promise.all()');
			// }}}

			return Promise.resolve()
				// Determine upload mode (or use settings.mode if specified) {{{
				.then(()=> {
					if (settings.mode != 'auto') return settings.mode;

					// Otherwise, try to guess from context
					if (!settings.file) { // No file given at all - assume we are prompting
						return 'prompt';
					} else if (
						settings.file // Being given SOMETHING
						&& !settings.multiple // ... and only one of it
						&& (Array.isArray(settings.file) || isPlainObject(settings.file)) // ... and it looks like a primative Array or a POJO
					) { // Assume we need to encode the raw file input
						return 'pojo';
					} else if (
						settings.file // Being given SOMETHING
						&& !settings.multiple // ... and only one of it
						&& ( // And its an accepted type
							settings.file instanceof File
							|| settings.file instanceof FileList
							|| settings.file instanceof Blob
							|| settings.file instanceof FormData
						)
					) {
						return 'encoded';
					} else {
						throw new Error('Unable to determine upload file. Specify a File, Bob, FormData, Object or Array or be more specific by setting {mode:String}');
					}
				})
				// }}}
				// Accept files from the detected mode -> Array {{{
				.then(mode => {
					this.debug('Uploading with mode', mode);
					switch (mode) {
						case 'pojo':
							this.debug('Encoding Array|POJO file to Blob');
							if (!path) throw new Error('Passing an Array|POJO to fileUpload() requires `{path:String}` to be specified');

							return [ // Encode POJO into an array of one File
								new File(
									[
										new Blob(
											[
												this._pojoToJson(settings.file)
											],
											{
												type: 'application/json',
											}
										),
									],
									this._parsePath(path).basename,
									{
										type: 'application/json',
									},
								),
							];
						case 'encoded':
							return settings.file instanceof Blob ? [new File([settings.file], this._parsePath(path).basename)] // Convert blobs into files
								: Array.from(settings.file);
						case 'prompt':
							return this._uploadBlob({
								multiple: settings.multiple,
							})
								.then(res => Array.from(res))
						default:
							throw new Error(`Unknown upload mode "${mode}"`);
					}
				})
				// }}}
				// Create $toast {{{
				.then(files => {
					if (settings.toast) {
						toastId = this.$toast.loading(
							files.length == 1
								? `Uploading "${this._parsePath('/UPLOAD/' + files[0].name).basename}"`
								: `Uploading ${files.length} files`
						);
					}
					return files;
				})
				// }}}
				// Upload all selected files {{{
				.then(files => {
					let stats = {
						totalSize: files.reduce((acc, file) => acc + file.size, 0),
						uploaded: 0,
					};

					return Promise.all(
						files.map(file => Promise.resolve()
							.then(()=> {
								let payload = { // Payload to pass to callbacks which allows mutation
									file,
									meta: {},
								};

								if (!settings.transcoders) return payload; // Skip transcoders

								return Promise.resolve()
									.then(()=> this.fileTranscoders.reduce((acc, cb) => acc
										.then(()=> cb.call(this, payload))
										.then(result => result && Promise.reject('END')) // Exit out of promise series chain on first non-falsy
									, Promise.resolve()))
									.then(()=> payload) // No transcoder triggered - return payload as is
									.catch(e => {
										if (e === 'END') return payload; // Exited cleanly in the middle of a promise series chain
										throw e; // Otherwise throw upwards
									})
							})
							.then(({file, meta}) => {
								// Check if the original input was a Blob. If so, it had no name,
								// and the `path` argument must be treated as the full final path.
								// We also check for 'pojo' mode which behaves the same way.
								let finalUploadPath = settings.mode === 'pojo' || (settings.mode === 'encoded' && options.file instanceof Blob) ?
									// In this case, pathPrefix *is* the full path including the filename.
									pathPrefix
									// Otherwise, the file object has its own name. The `path` argument
									// is the directory, so we append the file's name.
									: `${pathPrefix}/${file.name}`
								return this.supabase.storage
								.from(entity)
								.upload(finalUploadPath, file, {
									upsert: settings.overwrite,
									cacheControl: settings.cacheControl,
								})
								.then(({data: sbFile}) => ({file, meta, sbFile})) // Pass result + meta to next .then block
							})
							.then(({sbFile, file, meta}) => {
								if (!isEmpty(meta)) { // If we also want to populate meta we need to refetch the uploaded file by its name
									// Get the full path of the file we just uploaded inside the bucket
									const fullUploadedPath = sbFile.path;

									// Split it into the directory and the filename
									const pathParts = fullUploadedPath.split('/');
									const searchFilename = pathParts.pop();
									const directoryPathInBucket = pathParts.join('/');

									// Construct the path that the fileList function expects
									const listPath = `/${entity}/${directoryPathInBucket}`;

									return this.fileList(listPath, {
										search: searchFilename,
										meta: false,
										limit: 1,
									})
									.then(([newFile]) => {
										return this.replace(settings.metaPath(newFile), meta)
									})
									.then(()=> ({sbFile, file}))
								} else {
									return {sbFile, file};
								}
							})
							.then(({sbFile, file}) => {
								stats.uploaded += file.size;
								if (toastId) this.$toast.update(toastId, {
									progress: stats.uploaded / stats.totalSize,
								});
								return sbFile;
							})
						)
					);
				})
				// }}}
				.finally(()=> toastId && this.$toast.close(toastId))
		},


		/**
		* Fetch a file from the server into a Blob
		*
		* @param {SupabaseFile|String|Array<String>} input Either the SupabaseFile entity or the SupabaseFile name to fetch
		* @param {Object} [options] Additional options to mutate behaviour
		* @param {Boolean} [options.json=false] Parse the file as JSON and return the decoded content
		* @param {Boolean} [options.toast=true] Use $toast.loading to show progress while downloading
		* @returns {Promise<Blob>} The eventual file contents as a Blob object
		*/
		fileGet(input, options) {
			let path = input?.name || input;
			let settings = {
				json: false,
				toast: true,
				...options,
			};

			let toastId; // Eventual toastID used to track the loading progress
			let {entity, id, operand} = this.splitPath(path, {requireEntity: true, requireId: true});

			return Promise.resolve()
				.then(()=> {
					if (!settings.toast) return;
					toastId = this.$toast.loading(`Downloading "${operand}"`);
				})
				.then(()=> this.supabase.storage
					.from(entity)
					.download(`${id}/${operand}`)
					.then(({data}) => settings.json
						? data.text().then(d => this._jsonToPojo(d))
						: data
					)
				)
				.finally(()=> toastId && this.$toast.close(toastId))
		},


		/**
		* Wrapper around fileUpload() specifically for setting file contents en-masse
		*
		* @param {String|Array<String>} path The path to upload to (not the same as the file name)
		* @param {File|Blob|FormData|Object|Array} contents File contents to set
		* @param {Object} [options] Additional options to mutate behaviour, see `fileUpload()` for more details
		*
		* @returns {Promise} A promise which resolves when the operation has completed
		*/
		fileSet(path, contents, options) {
			return this.fileUpload(path, {
				file: contents,
				...options,
			});
		},


		/**
		* Download a file for the user
		* NOTE: This function presents a file to the user as a download, not retrieves its content like this.fileGet()
		*
		* @param {SupabaseFile|String|Array<String>} input Either the SupabaseFile entity or its name to download
		* @returns {Promise} A promise which resolves when the download operation has completed
		*/
		fileDownload(input) {
			let path = input?.name || input;
			let {entity, id, operand} = this.splitPath(path, {requireEntity: true, requireId: true});

			return this.fileGet({entity, id, operand})
				.then(blob => this._downloadBlob({
					blob,
					filename: operand.split('/').at(-1), // Extract final file name
				}))
		},


		/**
		* Zip all files within a path and pass to the user as a download
		*
		* @param {String|Array<String>} path The path to upload to (not the same as the file name)
		* @param {Object} [options] Additional options to mutate behaviour
		* @param {String} [options.filename=Date] Filename for the Zip
		* @param {Array<SupabaseFile>} [options.list] Existing file list, if provided it will be used as the destination file array rather than fetching it fresh
		* @param {Function} [options.onProgress] Function to call on progress updates. Called as `({total:Number, pending:Number, fetching:Number, writing:Number, written:Number})`
		* @param {Function} [options.onGeneratingZip] Function to call when building the final file. Called the same way as `options.onProgress()`
		* @param {Function} [options.onDone] Function to call when the zip has been built, just before offering to the user. Called the same way as `options.onProgress()`
		* @returns {Promise} A promise which resolves when the operation has completed
		*/
		fileZip(path, options) {
			let settings = {
				/* eslint-disable no-unused-vars */
				filename: (new Date).toISOString().replace(/:/g,'').replace(/\.\d{3}Z$/, '') + '.zip',
				list: null,
				onProgress(stats) {},
				onGeneratingZip(stats) {},
				onDone(stats) {},
				...options,
			};
			let {entity, id} = this.splitPath(path, {requireEntity: true, requireId: true});

			let stats = {
				total: 0,
				pending: 0,
				fetching: 0,
				writing: 0,
				written: 0,
			};

			/**
			* Simple function to merge an object into stats, call the onProgress event + return an optional value
			*
			* @param {Object} merge The values to be merged
			* @param {*} [result] Optional eventual result of the updated promise
			* @returns {Promise} A promise when `settings.onProgress` has completed
			*/
			let updateStats = (merge, result) => {
				Object.assign(stats, merge);
				return Promise.resolve(settings.onProgress(stats));
			};

			return Promise.resolve()
				.then(()=> settings.list || this.fileList({entity, id}))
				.then(files => updateStats({total: files.length})
					.then(()=> files)
				)
				.then(files => {
					let zipBlob = new ZipBlobWriter('application/zip');
					let zip = new ZipWriter(zipBlob);

					// Fetch + append all files into the zip
					return Promise.all(files.map(file => Promise.resolve()
						.then(()=> updateStats({fetching: stats.fetching + 1}))
						.then(()=> this.fileGet({entity, id, operand: file.path}))
						.then(blob => updateStats({fetching: stats.fetching - 1, writing: stats.writing + 1})
							.then(()=> blob)
						)
						.then(blob => zip.add(file.name, new ZipBlobReader(blob)))
						.then(()=> updateStats({writing: stats.writing - 1, written: stats.writing + 1}))
					))
						.then(()=> settings.onGeneratingZip(stats))
						.then(()=> zip.close())
				})
				.then(blob => Promise.resolve(settings.onDone(stats))
					.then(()=> blob)
				)
				.then(blob => this._downloadBlob({
					blob,
					filename: settings.filename,
				}))
		},


		/**
		* Create a file snapshot of an existing file
		*
		* @param {String|Array<String>} path The path to snapshot (not the same as the file name)
		* @param {Object} [options] Additional options to mutate behaviour
		* @param {Array<SupabaseFile>} [options.list] Existing file list, if provided it will be used as the destination file array rather than fetching it fresh
		* @returns {Promise<String>} A promise which resolves with the eventual snapshot operand
		*/
		fileSnapshot(path, options) {
			let settings = {
				list: null,
				...options,
			};

			let {entity, id, operand} = this.splitPath(path, {requireEntity: true, requireId: true});
			let operandParts = operand.split('/');
			let {dirname, filename, ext} = this._parsePath(operandParts.pop());

			return Promise.resolve()
				.then(()=> settings.list || this.fileList({entity, id}))
				// Find next applicable version name {{{
				.then(list => new Promise((resolve, reject) => {
					let usedNames = new Set(list.map(l => l.name));

					for (let v = 1; v++; v < 100) {
						let tryName = operandParts.join('/')
							+ `${dirname}${filename}_v${v}.${ext}`

						// Keep trying until we don't hit a conflict
						if (!usedNames.has(tryName)) return resolve(tryName);
					}
					reject('Cannot find a non-conflicting file name');
				}))
				// }}}
				.then(newName => this.supabase.storage
					.from(entity)
					.copy(`${id}/${operand}`, `${id}/${newName}`)
					.then(()=> newName)
				)
		},


		/**
		* Remove a file
		*
		* @param {String|Array<String>} path The path to remove (not the same as the file name)
		*
		* @returns {Promise} A promise which resolves when the operation has completed
		*/
		fileRemove(path) {
			let {entity, id, operand} = this.splitPath(path, {requireEntity: true, requireId: true});

			return this.supabase.storage
				.from(entity)
				.remove([`${id}/${operand}`])
		},


		/**
		* Return various meta information for a given file
		* This function processes all workers in `this.fileTypes` until one succeeds
		*
		* @param {SupabaseFile} file The file object to return meta-data for
		*
		* @returns {Object} An object describing the file type
		* @property {String} icon A Fontawesome compatible CSS class to use the icon of
		* @property {String} type A human readable description of the file type
		* @property {String} [href] Optional follow-on href to navigate if the user selects this file
		*/
		fileType(file) {
			let response;
			this.fileTypes.some(ft => response = ft.call(this, file));

			return response;
		},
		// }}}

		// RPC - rpc() {{{
		/**
		* Wrap the Supabase RPC function to return results or throw promises on failure
		*
		* @param {String} fn The function name to run
		* @param {Object} [args] Optional, named function arguments
		*
		* @returns {Promise<*>} The eventual RPC response (or a thrown promise on fail)
		*/
		rpc(fn, args) {
			return this.supabase.rpc(fn, args)
				.then(({data, error}) => { // Force RPC() to act as a promise by calling `then` (otherwise it acts as a query)
					if (error) throw new Error(`${error.code} - ${error.message}`);
					return data;
				})
		},
		// }}}

		// Helper functions - _downloadBlob(), _uploadBlob(), _parsePath(), _pojoToJson(), _jsonToPojo() {{{
		/**
		* Internal function to provide a blob as a downloadable file
		* @private
		* @param {Object} options Additional options to mutate behaviour
		* @param {Blob} options.blob Blob object to download
		* @param {String} options.filename The filename to default to when saving
		*/
		_downloadBlob(options) {
			let blobUrl = URL.createObjectURL(options.blob);

			let el = document.createElement('a');
			el.href = blobUrl;
			el.download = options.filename;

			document.body.appendChild(el);
			el.click();
			el.remove();
		},


		/**
		* Internal function to prompt for a file from disk, returning a File(s) object
		*
		* @param {Object} [options] Additional options to mutate behaviour
		* @param {Boolean} [options.multiple=false] If prompting, allow multiple file selection (conflicts with `meta`)
		* @param {String} [options.accept] If prompting, Add additional file type restrictions
		*
		* @returns {Promise<FileList>} The output FileList object generated by the user OR the promise will reject with `'CANCEL'`
		*/
		_uploadBlob(options) {
			let settings = {
				multiple: false,
				accept: null,
				...options,
			};

			return new Promise((resolve, reject) => {
				// Create outer, hidden wrapper
				let wrapper = document.createElement('div');
				wrapper.classList.add('d-none');
				document.body.append(wrapper);

				// Create inner input file element we fake interaction with
				let fileControl = document.createElement('input');
				fileControl.type = 'file';
				if (settings.multiple) fileControl.multiple = true;
				if (settings.accept) fileControl.accept = settings.accept;
				wrapper.append(fileControl);
				fileControl.addEventListener('change', e => {
					if (e.target.files.length > 0) {
						resolve(e.target.files);
					} else {
						reject('CANCEL');
					}
					wrapper.remove();
				});
				fileControl.addEventListener('cancel', ()=> {
					wrapper.remove();
					reject();
				});
				fileControl.click();
			})
		},


		/**
		* Parse a file component into a `dirname`, `filename` + `ext`[tention]
		* If a file name fails to parse this function will throw
		*
		* @param {String} path Path to parse
		*
		* @returns {Object} The parsed file components
		* @property {String} dirname Any directory portion of the input path
		* @property {String} basename The filename + extention (i.e. everything without directory name)
		* @property {String} filename The base filename without extension
		* @property {String} ext The extension (sans dot prefix, always lower case)
		*
		* @example Parse a simple filename
		* this._parsePath('/myfile.txt') //= {dirname: '/', basename: 'myfile.txt', filename: 'myfile', ext: 'txt'}
		*/
		_parsePath(path) {
			if (!path.startsWith('/')) throw new Error(`All file paths must start with a slash. Given "${path}"`);
			let {dirname, basename, filename, ext} = /^(?<dirname>.*\/)(?<basename>(?<filename>.+?)(?:\.(?<ext>.+?))?)$/.exec(path)?.groups || {};
			if (!dirname || !filename) throw new Error('Unable to decode filename');
			ext = ext ? ext.toLowerCase() : '';

			return {dirname, basename, filename, ext};
		},


		/**
		* Encode a POJO to a JSON string
		* This is really just a wrapper around `JSON.stringify()` which could also tidy up output + inject meta information
		* @param {Object|Array} pojo Input object to encode
		* @returns {String} Encoded JSON string
		*/
		_pojoToJson(pojo) {
			return JSON.stringify(pojo, null, '\t');
		},


		/**
		* Decode a JSON string into a POJO
		* This is really just a wrapper around `JSON.parse()` which could also tidy up input + inject meta information
		* @param {String} str The input string to parse
		* @returns {Object|Array} Decoded POJO output
		*/
		_jsonToPojo(str) {
			return JSON.parse(str);
		},


		/**
		* Lazily convert a string to a UUID
		* This tries to mash strings that are "sort of" already like UUIDs into them by adding padding
		*
		* @param {String} input Input string
		* @returns {String} A UUID compatible string
		*/
		_String2UUID(input) {
			let candidate = input.replace(/[^0-9a-f]+/g, '').substr(0, 32).padStart(32, '0');
			return candidate.substr(0, 8) + '-'
			+ candidate.substr(8, 4) + '-'
			+ candidate.substr(12, 4) + '-'
			+ candidate.substr(16, 4) + '-'
			+ candidate.substr(20, 12);
		},
		// }}}

	},
	created() {
		if (!this.supabaseUrl || !this.supabaseKey) throw new Error('Cannot connect to Supabase without passing supabaseUrl + supabaseKey');

		this.debug('Connecting to Supabase URL', this.supabaseUrl);
		this.supabase = Supabase(this.supabaseUrl, this.supabaseKey);

		return this.$services.require('$toast');
	},
}
</script>
